# 3.17区别：new和make

## new

内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针

```go
func new(Type) *Type
```

根据这段描述，我们可以自己实现一个类似new的功能

```go
func newInt() *int {
  var i int
  return &i
}
someInt := newInt()
```

new是一个用来分配内存的内置函数（C++中是运算符），但他和大多数其他语言不同，new不会初始化内存（C++中会分配并调用构造函数），而是将内存归0（也就是初始化成0）。即，new(T)给类型T分配了一个存储了0值的内存并且返回它的地址（在C++中相当于先调用malloc分配内存，然后调用memset初始化内存），返回的类型为**T*。用Go的术语来说，new返回一个指针，它指向新分配的T类型的零值的指针。

因为被new返回的内存是零值，当你在设计数据结构时，这非常有帮助。由于每个数据成员/字段的类型都是零值，所以他们可以直接使用而不需要进一步地初始化。这意味着在使用这些数据结构时，可以直接通过new创建而不需要再做其他工作，他们就能正常使用。

## make

内建函数make分配并初始化一个类型为切片、映射、或通道的对象。其第一个实参为类型，而非值。make的返回类型与其参数相同，而非指向它的指针。其具体结果取决于具体的类型：

> 切片：size指定了其长度。该切片的容量等于其长度。切片支持第二个整数实参可用来指定不同的容量；它必须不小于其长度，因此 make([]int, 0, 10) 会分配一个长度为0，容量为10的切片。
> 映射：初始分配的创建取决于size，但产生的映射长度为0。size可以省略，这种情况下就会分配一个小的起始大小。
> 通道：通道的缓存根据指定的缓存容量初始化。若 size为零或被省略，该信道即为无缓存的。

```go
func make(Type, size IntegerType) Type
```

内置函数make(T, args)的目的不同于new(T)。它只用于创建切片、映射和信道(channel)，它返回一个T类型(不是*T类型)的被初始化了(不是0值)的值。和new的区别是，这三种类型为底层数据结构的引用，这些数据结构在使用前必须初始化。例如，切片的内部有三个元素，分别为：一个指向数据(底层数组)的指针，长度和容量。直到这些元素被初始化之前，切片的值为nil。对于切片、映射和信道，make会初始化内部的数据结构并且准备需要使用的值。

## 区别

```go
var p *[]int = new([]int)       // 分配切片数据结构; *p == nil; 几乎没有作用
var v  []int = make([]int, 100) // 切片v引用一个[100]int的数组

// 没有必要:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 惯用做法:
v := make([]int, 100)

```

